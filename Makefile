# We use bashisms in this Makefile.
SHELL := /bin/bash

# Go compiler/toolchain and extra related binaries we ues/need.
GO_PARALLEL :=
GO_CMD      := go
GO_BUILD    := $(GO_CMD) build $(GO_PARALLEL)
GO_GEN      := $(GO_CMD) generate -x
GO_INSTALL  := $(GO_CMD) install
GO_FMT      := gofmt
GO_CYCLO    := gocyclo
GO_LINT     := golint
GO_CILINT   := golangci-lint
GO_VERSION  ?= 1.20.4
GOLICENSES_VERSION  ?= v1.5.0

# TEST_TAGS is the set of extra build tags passed for tests.
TEST_TAGS := test
GO_TEST   := $(GO_CMD) test $(GO_PARALLEL) -tags $(TEST_TAGS)
GO_VET    := $(GO_CMD) vet -tags $(TEST_TAGS)

# Disable some golangci_lint checkers for now until we have an more acceptable baseline...
GO_CILINT_CHECKERS := -D structcheck -E golint,gofmt
GO_CILINT_RUNFLAGS := --build-tags $(TEST_TAGS)

# ShellCheck for checking shell scripts.
SHELLCHECK := shellcheck

# Binaries and directories for installation.
INSTALL    := install
PREFIX     ?= /usr
BINDIR     ?= $(PREFIX)/bin

# Directories (in cmd) with go code we'll want to build and install.
BUILD_DIRS = $(shell find cmd -name \*.go | sed 's:cmd/::g;s:/.*::g' | uniq)
BUILD_BINS = $(foreach dir,$(BUILD_DIRS),bin/$(dir))

# List of our active go modules.
GO_LIST_MODULES := $(GO_CMD) list ./... | grep -v vendor/
GO_PKG_SRC = $(shell find pkg -name \*.go)

# Determine binary version and buildid, and versions for rpm, deb, and tar packages.
BUILD_VERSION := $(shell scripts/build/get-buildid --version --shell=no)
BUILD_BUILDID := $(shell scripts/build/get-buildid --buildid --shell=no)
RPM_VERSION   := $(shell scripts/build/get-buildid --rpm --shell=no)
DEB_VERSION   := $(shell scripts/build/get-buildid --deb --shell=no)
TAR_VERSION   := $(shell scripts/build/get-buildid --tar --shell=no)

# Git (tagged) version and revisions we'll use to linker-tag our binaries with.
RANDOM_ID := "$(shell head -c20 /dev/urandom | od -An -tx1 | tr -d ' \n')"

ifdef STATIC
    STATIC_LDFLAGS:=-extldflags=-static
    BUILD_TAGS:=-tags osusergo,netgo
endif

LDFLAGS    = \
    -ldflags "$(STATIC_LDFLAGS) -X=github.com/intel/memtierd/pkg/version.Version=$(BUILD_VERSION) \
             -X=github.com/intel/memtierd/pkg/version.Build=$(BUILD_BUILDID) \
             -B 0x$(RANDOM_ID)"

# Build non-optimized version for debugging on make DEBUG=1.
DEBUG ?= 0
ifeq ($(DEBUG),1)
    GCFLAGS=-gcflags "all=-N -l"
else
    GCFLAGS=
endif

# Build with race detector on make RACE=1.
RACE ?= 0
ifeq ($(RACE),1)
    RACEFLAGS=-race
else
    RACEFLAGS=
endif

# Release/end-to-end testing. Specify E2E_TESTS to override the default test set.
E2E_RUN := reinstall_memtierd=1 distro=debian-sid test/e2e/run_tests.sh

FUZZ_TIME ?= 10s

# tar-related commands and options.
TAR        := tar
TAR_UPDATE := $(TAR) -uf
GZIP       := gzip
GZIP_DC    := gzip -dc
GZEXT      := .gz

# Metadata for packages, changelog, etc.
USER_NAME  ?= $(shell git config user.name)
USER_EMAIL ?= $(shell git config user.email)
BUILD_DATE ?= $(shell date -R)

# dist tarball target name
ifneq ($(wildcard .git/.),)
    DIST_TARGET = dist-git
else
    DIST_TARGET = dist-cwd
endif

# Paths to exclude from tarballs generated by dist-cwd.
DIST_EXCLUDE := \
    --exclude="./$$tarball*" \
    --exclude='./memtierd-*'

# Path name transformations for tarballs generated by dist-cwd.
DIST_TRANSFORM := \
    --transform='s:^.:memtierd-$(TAR_VERSION):'

# Determine distro ID, version and package type.
DISTRO_ID      := $(shell . /etc/os-release; echo "$${ID:-unknown}")
DISTRO_VERSION := $(shell . /etc/os-release; echo "$${VERSION_ID:-unknown}")
DISTRO_PACKAGE := $(shell echo $(DISTRO_ID) | tr -d ' \t' | \
    sed -E 's/.*((centos)|(fedora)|(suse)).*/rpm/;s/.*((ubuntu)|(debian)).*/deb/')

# Be quiet by default but let folks override it with Q= or V=1 on the command line.
ifneq ($(V),1)
  Q := @
endif

# Default target: just build everything.
all: build

#
# Generic targets: build, install, clean, build images.
#

build: $(BUILD_BINS)

build-static:
	$(MAKE) STATIC=1 build

install: $(BUILD_BINS) $(foreach dir,$(BUILD_DIRS),install-bin-$(dir)) \
    $(foreach dir,$(BUILD_DIRS),install-config-$(dir))

clean: clean-bin

#
# Rules for building and installing binaries, or building docker images, and cleaning up.
#

bin/%: .static.%.$(STATIC)
	$(Q)bin=$(notdir $@); src=./cmd/$$bin; \
	echo "Building $$([ -n "$(STATIC)" ] && echo 'static ')$@ (version $(BUILD_VERSION), build $(BUILD_BUILDID))..."; \
	mkdir -p bin && \
	$(GO_BUILD) $(BUILD_TAGS) $(LDFLAGS) $(GCFLAGS) $(RACEFLAGS) -o bin/ $$src

.static.%.$(STATIC):
	$(Q)if [ ! -f "$@" ]; then \
	    touch "$@"; \
	fi; \
	old="$@"; old="$${old%.*}"; \
        if [ -n "$(STATIC)" ]; then \
	    rm -f "$$old."; \
	else \
	    rm -f "$$old.1"; \
	fi

.PRECIOUS: $(foreach dir,$(BUILD_DIRS),.static.$(dir).1 .static.$(dir).)

install-bin-%: bin/%
	$(Q)bin=$(patsubst install-bin-%,%,$@); dir=cmd/$$bin; \
	echo "Installing $$bin in $(DESTDIR)$(BINDIR)..."; \
	$(INSTALL) -d $(DESTDIR)$(BINDIR) && \
	$(INSTALL) -m 0755 -t $(DESTDIR)$(BINDIR) bin/$$bin; \

install-config-%:
	$(Q)bin=$(patsubst install-config-%,%,$@); dir=cmd/$$bin; \
	echo "Installing sample configuration collateral for $$bin..."; \
	$(INSTALL) -d $(DESTDIR)$(CONFIGDIR) && \
	for f in $$(find $$dir -name \*.cfg.sample); do \
	    echo "  $$f in $(DESTDIR)$(CONFIGDIR)..."; \
	    df=$${f##*/}; \
	    $(INSTALL) -m 0644 -T $$f $(DESTDIR)$(CONFIGDIR)/$${df}; \
	done

install-minimal-docs:
	$(Q)echo "Installing minimal documentation to $(DOCDIR)..."; \
	$(INSTALL) -d $(DESTDIR)$(DOCDIR) && \
	for f in LICENSE docs/security.md; do \
	    echo "  $$f in $(DESTDIR)$(DOCDIR)..."; \
	    df=$${f##*/}; \
	    $(INSTALL) -m 0644 -T $$f $(DESTDIR)$(DOCDIR)/$${df}; \
	done

install-licenses:
	$(Q)for cmd in $(BUILD_DIRS); do \
	    install -D LICENSE $(DESTDIR)/licenses/$$cmd/LICENSE && \
	    go-licenses save ./cmd/$$cmd \
	        --ignore github.com/intel/memtierd \
	        --save_path $(DESTDIR)/licenses/$$cmd/go-licenses; \
	done

clean-bin: $(foreach dir,$(BUILD_DIRS),clean-$(dir))
	$(Q)rm -f .static.*

clean-%:
	$(Q)bin=$(patsubst clean-%,%,$@); src=cmd/$$bin; \
	echo "Cleaning up $$bin..."; \
	rm -f bin/$$bin

clean-gen:
	$(Q)rm -f $(GEN_TARGETS)

#
# Rules for format checking, various code quality and complexity checks and measures.
#

format:
	$(Q)report=`$(GO_FMT) -s -d -w $$(find cmd pkg test/functional -name \*.go)`; \
	if [ -n "$$report" ]; then \
	    echo "$$report"; \
	    exit 1; \
	fi

vet:
	$(Q)$(GO_VET) $(shell $(GO_LIST_MODULES))

cyclomatic-check:
	$(Q)report=`$(GO_CYCLO) -over 15 cmd pkg`; \
	if [ -n "$$report" ]; then \
	    echo "Complexity is over 15 in"; \
	    echo "$$report"; \
	    exit 1; \
	fi

lint:
	$(Q)rc=0; \
	for f in $$(find -name \*.go | grep -v \.\/vendor); do \
	    $(GO_LINT) -set_exit_status $$f || rc=1; \
	done; \
	exit $$rc

golangci-lint:
	$(Q)$(GO_CILINT) run $(GO_CILINT_RUNFLAGS) $(GO_CILINT_CHECKERS)

shellcheck:
	$(Q)for f in $$(git grep -n '^#!/bin/.*sh *' | grep ':1:#!' | sed 's/:1:.*//'); do \
	    echo "shellchecking $$f..."; \
	    $(SHELLCHECK) $$f; \
	done


#
# Rules for running unit/module tests.
#

test:
ifndef WHAT
	$(Q)$(GO_TEST) -race -coverprofile=coverage.txt -covermode=atomic \
	    $(shell $(GO_LIST_MODULES))
else
	$(Q)if [ -n '$(TESTS)' ]; then \
	        run="-run $(TESTS)"; \
	    fi; \
	cd $(WHAT) && \
            $(GO_TEST) $$run -v -cover -coverprofile cover.out || rc=1; \
            $(GO_CMD) tool cover -html=cover.out -o coverage.html; \
            rm cover.out; \
            echo "Coverage report: file://$$(realpath coverage.html)"; \
            exit $$rc
endif

fuzz-test fuzztest:
	$(Q)echo "Fuzzing FUZZ_TIME=$(FUZZ_TIME) FUZZ_PROMPT_CREATE=$(FUZZ_PROMPT_CREATE)" && \
	cd pkg/memtier && \
	FUZZ_PROMPT_CREATE=$(FUZZ_PROMPT_CREATE) $(GO_TEST) -cover -race -fuzz=Fuzz -fuzztime=$(FUZZ_TIME) -parallel=4

race-test racetest:
ifndef WHAT
	$(Q)$(GO_TEST) -race -coverprofile=coverage.txt -covermode=atomic \
	    $(shell $(GO_LIST_MODULES))
else
	$(Q)cd $(WHAT) && \
	    $(GO_TEST) -race -coverprofile=cover.out -covermode=atomic || rc=1; \
            $(GO_CMD) tool cover -html=cover.out -o coverage.html; \
            rm cover.out; \
            echo "Coverage report: file://$$(realpath coverage.html)"; \
            exit $$rc
endif

release-test: e2e-test

e2e-test: build-static
	$(Q)tests="$(if $(E2E_TESTS),$(E2E_TESTS),test/e2e/memtierd.test-suite)"; \
	$(E2E_RUN) $$tests; \
	if [ "$$?" != "0" ]; then \
	    echo "You drop into interactive mode upon failures if you run e2e tests as"; \
	    echo "    on_verify_fail=interactive $(E2E_RUN) $$tests"; \
	    exit 1; \
	fi

#
# Rules for building dist-tarballs, rpm, and deb packages.
#

dist: $(DIST_TARGET)

dist-git:
	$(Q)echo "Using git to create dist tarball $(TAR_VERSION) from $(BUILD_BUILDID)..."; \
	tardir=memtierd-$(TAR_VERSION) && \
	tarball=memtierd-$(TAR_VERSION).tar && \
	git archive --format=tar --prefix=$$tardir/ HEAD > $$tarball && \
	mkdir -p $$tardir && \
	    echo $(BUILD_VERSION) > $$tardir/version && \
	    echo $(BUILD_BUILDID) > $$tardir/buildid && \
	$(TAR) -uf $$tarball $$tardir && \
	rm -f $$tarball.* && \
	$(GZIP) $$tarball && \
	rm -fr $$tardir

dist-cwd:
	$(Q)echo "Using tar to create dist tarball $(TAR_VERSION) from $$(pwd)..."; \
	tardir=memtierd-$(TAR_VERSION) && \
	tarball=memtierd-$(TAR_VERSION).tar && \
	$(TAR) $(DIST_EXCLUDE) $(DIST_TRANSFORM) -cvf - . > $$tarball && \
	mkdir -p $$tardir && \
	    echo $(BUILD_VERSION) > $$tardir/version && \
	    echo $(BUILD_BUILDID) > $$tardir/buildid && \
	$(TAR_UPDATE) $$tarball $$tardir && \
	rm -f $$tarball.* && \
	$(GZIP) $$tarball && \
	rm -fr $$tardir

# Rule for installing in-repo git hooks.
install-git-hooks:
	$(Q)if [ -d .git -a ! -e .git-hooks.redirected ]; then \
	    echo -n "Redirecting git hooks to .githooks..."; \
	    git config core.hookspath .githooks && \
	    touch .git-hooks.redirected && \
	    echo "done."; \
	fi

#
# go dependencies for our binaries (careful with that axe, Eugene...)
#

bin/memtierd: $(wildcard cmd/memtierd/*.go) \
    $(shell for dir in \
                  $(shell go list -f '{{ join .Deps  "\n"}}' ./cmd/memtierd/... | \
                          grep memtierd/pkg/ | \
                          sed 's#github.com/intel/memtierd/##g'); do \
                find $$dir -name \*.go; \
            done | sort | uniq)

bin/meme: $(wildcard cmd/meme/*.go) $(wildcard pkg/version/*.go)

help:
	@echo "make [OPTION...] TARGET..."
	@echo "Most popular OPTIONs:"
	@echo "  DEBUG=1      include debug symbols"
	@echo "  STATIC=1     build a statically linked binary (no libc dependency)"
	@echo "  Q=\"\"       verbose output (see commands)"
	@echo "Most popular TARGETs:"
	@echo "  bin/memtierd build memtierd binary (default)"
	@echo "  bin/meme     build memory execiser, a configurable test application (default)"
	@echo "  test         run unit tests"
	@echo "  fuzz-test    run fuzz tests"
	@echo "  e2e-test     run e2e tests"

# phony targets
.PHONY: all build install clean test release-test e2e-test \
	fuzztest fuzz-test help \
	format vet cyclomatic-check lint golangci-lint
